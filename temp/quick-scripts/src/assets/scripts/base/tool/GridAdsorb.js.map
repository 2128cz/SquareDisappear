{"version":3,"sources":["assets\\scripts\\base\\tool\\GridAdsorb.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import { mathMacro as mm } from '../class/DevelopersToolGlobal';\r\nclass GridAbsorb_Private {\r\n    protected static _ExclusiveGrid = null;\r\n\r\n    /**\r\n     * 网格对齐\r\n     * 创建的同时，如果类单例中不存在实例，则将此实例赋予到类单例中\r\n     */\r\n    constructor(axisNum?: cc.Vec3, cellSize?: cc.Vec3) {\r\n        if (axisNum) {\r\n            this._GridAxisCellNum = axisNum;\r\n            if (cellSize) {\r\n                this._CellSize = cellSize;\r\n                this._GridSize = new cc.Vec3(\r\n                    axisNum.x * cellSize.x,\r\n                    axisNum.y * cellSize.y,\r\n                    axisNum.z * cellSize.z\r\n                );\r\n            }\r\n        }\r\n        if (!GridAbsorb._ExclusiveGrid) {\r\n            GridAbsorb._ExclusiveGrid = this;\r\n        }\r\n    }\r\n    // 晶胞尺寸\r\n    protected _CellSize: cc.Vec3 = new cc.Vec3(100);\r\n    // 网格计算原点偏移\r\n    protected _GridOffset: cc.Vec3 = new cc.Vec3(0);\r\n    // 网格计算原点偏移\r\n    // protected _OriginOffset: cc.Vec3 = new cc.Vec3(0);\r\n    // 网格总尺寸\r\n    protected _GridSize: cc.Vec3 = null;\r\n    // 各轴晶胞数量\r\n    protected _GridAxisCellNum: cc.Vec3 = new cc.Vec3(100);\r\n    // 网格中心锚点\r\n    protected _GridEdgeAnchor: cc.Vec3 = new cc.Vec3(.5);\r\n\r\n    // SIGNPOST 网格查找                                                                                \r\n\r\n    /** \r\n     * 从各轴索引获得网格坐标  \r\n     * cocos和unity都是y轴向上，xz为平面  \r\n     * 为了适配平面坐标，z为深度轴  \r\n     * 通常情况下网格原点为0，而索引0在底部，如果需要0在原点首先需要将偏移量向上移动整个网格尺寸的一半\r\n     * @param {intVec3} index\r\n     * @return {int}\r\n     */\r\n    public getGridPositionByIndex<T extends cc.Vec3 | cc.Vec2>(index: T): T {\r\n        let self = this;\r\n        function getPos(axis: string): number {\r\n            // 索引限制\r\n            let axisIndex = mm.PMod(Math.floor(index[axis]), self._GridAxisCellNum[axis]);\r\n            // 索引坐标\r\n            let axisPos = axisIndex * self._CellSize[axis] + self._GridOffset[axis];\r\n            // 归一化\r\n            let normalPos = mm.PMod(axisPos / self._GridSize[axis], 1);\r\n            normalPos - normalPos - Math.floor(normalPos);\r\n            return (normalPos + (self._GridEdgeAnchor[axis] - .5)) * self._GridSize[axis];\r\n        }\r\n        let x = getPos('x');\r\n        let y = getPos('y');\r\n        if (index instanceof cc.Vec3) {\r\n            let z = getPos('z');\r\n            return new cc.Vec3(x, y, z) as T;\r\n        }\r\n        return new cc.Vec2(x, y) as T;\r\n    }\r\n\r\n}\r\nexport default class GridAbsorb extends GridAbsorb_Private {\r\n\r\n    /**\r\n     * 获取静态唯一网格实例\r\n     */\r\n    public static get grid() {\r\n        this._ExclusiveGrid = this._ExclusiveGrid || new GridAbsorb()\r\n        return this._ExclusiveGrid;\r\n    }\r\n    /**\r\n     * 将实例设置到静态唯一网格实例\r\n     */\r\n    public static set grid(grid: GridAbsorb) {\r\n        this._ExclusiveGrid = grid;\r\n    }\r\n\r\n    /**\r\n     * 获取网格偏移量\r\n     */\r\n    public get offset(): cc.Vec3 {\r\n        return this._GridOffset;\r\n    }\r\n    /**\r\n     * 设置网格偏移量  \r\n     */\r\n    public set offset(offset: cc.Vec3) {\r\n        let self = this;\r\n        let newOffset = this._GridOffset.add(offset);\r\n        function vecMod(axis: string): number {\r\n            return newOffset[axis] % self.gridSize[axis];\r\n        }\r\n        this._GridOffset = new cc.Vec3(vecMod('x'), vecMod('y'), vecMod('z'))\r\n    }\r\n\r\n    /**\r\n     * 获取单元格尺寸\r\n     */\r\n    public get cellSize(): cc.Vec3 {\r\n        return this._CellSize;\r\n    }\r\n    /**\r\n     * 设置单元格尺寸\r\n     */\r\n    public set cellSize(size: cc.Vec3) {\r\n        this._CellSize = size;\r\n    }\r\n\r\n    /**\r\n     * 获取网格轴晶格数量\r\n     */\r\n    public get cellNum(): cc.Vec3 {\r\n        return this._GridAxisCellNum;\r\n    }\r\n    /**\r\n     * 设置网格轴晶格数量\r\n     */\r\n    public set cellNum(num: cc.Vec3) {\r\n        this._GridAxisCellNum = num;\r\n    }\r\n\r\n    /**\r\n     * 获取网格尺寸\r\n     */\r\n    public get gridSize(): cc.Vec3 {\r\n        return this._GridSize;\r\n    }\r\n    /**\r\n     * 设置网格尺寸\r\n     */\r\n    public set gridSize(size: cc.Vec3) {\r\n        this._GridSize = size;\r\n    }\r\n\r\n    /**\r\n     * 获取网格边缘锚点  \r\n     * 取值在[0, 1]\r\n     */\r\n    public get anchor(): cc.Vec3 {\r\n        return this._GridEdgeAnchor;\r\n        // function toAlige(vec: cc.Vec2) {\r\n        //     return (vec.x - vec.y + 1) / 2;\r\n        // }\r\n        // return new cc.Vec3(\r\n        //     toAlige(this._GridEdgeAnchor_X),\r\n        //     toAlige(this._GridEdgeAnchor_Y),\r\n        //     toAlige(this._GridEdgeAnchor_Z)\r\n        // );\r\n    }\r\n    /**\r\n     * 设置网格边缘锚点\r\n     * 取值在[0, 1]，跟随引擎\r\n     */\r\n    public set anchor(anchor: cc.Vec3) {\r\n        let Anchor = anchor.normalize();\r\n        Anchor.x = Math.abs(Anchor.x);\r\n        Anchor.y = Math.abs(Anchor.y);\r\n        Anchor.z = Math.abs(Anchor.z);\r\n        this._GridEdgeAnchor = Anchor;\r\n        // function toAnchor(num: number) {\r\n        //     if (!num) return new cc.Vec2(.5);\r\n        //     let axis = Math.max(Math.min(num, 1), 0) - .5;\r\n        //     return new cc.Vec2(.5 - axis, .5 + axis);\r\n        // }\r\n        // this._GridEdgeAnchor_X = toAnchor(anchor.x);\r\n        // this._GridEdgeAnchor_Y = toAnchor(anchor.y);\r\n        // this._GridEdgeAnchor_Z = toAnchor(anchor.z);\r\n    }\r\n}"]}